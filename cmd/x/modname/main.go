package main

import (
	"errors"
	"fmt"
	"golang.org/x/mod/modfile"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
)

func main() {
	start, err := os.Getwd()

	if err != nil {
		log.Fatalf("Unable to get current working directory: %s", err)
	}

	_, pkg := path.Split(start)

	current := start

	for {
		mod := path.Join(current, "go.mod")

		/* #nosec */
		f, err := os.Open(mod)

		if errors.Is(err, os.ErrNotExist) {
			next := filepath.Dir(current)

			if current == next {
				log.Fatalf("Unable to find go.mod file.")
			}

			current = next
		} else if err != nil {
			log.Fatalf("Unable to open file: %s", err)
		} else {
			data, err := ioutil.ReadAll(f)
			_ = f.Close()

			if err != nil {
				log.Fatalf("Unable to read go.mod file at %s: %s", mod, err)
			}

			module, err := modfile.Parse(mod, data, nil)

			if err != nil {
				log.Fatalf("Unable to read module file: %s", err)
			}

			out, err := os.Create("modname_gen.go")

			if err != nil {
				log.Fatalf("Unable to open modname.go for writing: %s", err)
			}

			_, _ = fmt.Printf("modname: %s: wrote %s\n", start, out.Name())

			_, err = out.WriteString("// Code generated by \"modname\"; DO NOT EDIT.\n")
			_, err = out.WriteString(fmt.Sprintf("package %s\n", pkg))
			_, err = out.WriteString("\n")
			_, err = out.WriteString(fmt.Sprintf("const GoModule = \"%s\"\n", module.Module.Mod.Path))

			_ = out.Close()

			break
		}
	}
}
